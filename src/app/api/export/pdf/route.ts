import { NextResponse } from 'next/server';
import { auth } from '@clerk/nextjs/server';
import { api } from '../../../../../convex/_generated/api';
import { fetchQuery } from 'convex/nextjs';
import PDFDocument from 'pdfkit';

export const runtime = 'nodejs';

function renderHeader(doc: PDFKit.PDFDocument, title: string) {
  doc
    .fontSize(18)
    .text('SubWise', { align: 'left' })
    .moveDown(0.2)
    .fontSize(12)
    .fillColor('#666')
    .text(title)
    .fillColor('#000')
    .moveDown(1);
}

function renderTable(doc: PDFKit.PDFDocument, rows: Array<string[]>) {
  const colWidths = [160, 60, 60, 80, 120, 80];
  const headers = ['Name', 'Cost', 'Currency', 'Billing', 'Next Billing Date', 'Category'];

  doc.fontSize(11).fillColor('#111').text(headers[0], { continued: true, width: colWidths[0] })
    .text(headers[1], { continued: true, width: colWidths[1] })
    .text(headers[2], { continued: true, width: colWidths[2] })
    .text(headers[3], { continued: true, width: colWidths[3] })
    .text(headers[4], { continued: true, width: colWidths[4] })
    .text(headers[5], { width: colWidths[5] })
    .moveDown(0.5);

  doc.moveTo(doc.x, doc.y).lineTo(doc.page.width - doc.page.margins.right, doc.y).strokeColor('#ddd').stroke().moveDown(0.5).strokeColor('#000');

  rows.forEach((r) => {
    doc.fontSize(10).fillColor('#333')
      .text(r[0], { continued: true, width: colWidths[0] })
      .text(r[1], { continued: true, width: colWidths[1] })
      .text(r[2], { continued: true, width: colWidths[2] })
      .text(r[3], { continued: true, width: colWidths[3] })
      .text(r[4], { continued: true, width: colWidths[4] })
      .text(r[5], { width: colWidths[5] })
      .moveDown(0.2);
  });
}

function hasExportAccess(tier?: string) {
  if (!tier) return false;
  if (tier === 'premium_user' || tier === 'premium') return true;
  if (tier === 'automate' || tier === 'automate_1') return true;
  return tier === 'plus';
}

export async function GET() {
  const { userId } = await auth();
  if (!userId) return new NextResponse('Unauthorized', { status: 401 });

  const user = await fetchQuery(api.users.getUserByClerkId, { clerkId: userId });
  if (!user || !hasExportAccess(user.tier)) return new NextResponse('Forbidden: Plus plan required', { status: 403 });

  const subs = await fetchQuery(api.subscriptions.getUserSubscriptions, { clerkId: userId });

  const doc = new PDFDocument({ margin: 40 });
  const chunks: Uint8Array[] = [];

  return await new Promise<NextResponse>((resolve, reject) => {
    doc.on('data', (c) => chunks.push(c));
    doc.on('end', () => {
      const pdfBuffer = Buffer.concat(chunks.map((u) => Buffer.from(u)));
      resolve(new NextResponse(pdfBuffer, {
        status: 200,
        headers: {
          'Content-Type': 'application/pdf',
          'Content-Disposition': 'attachment; filename="subwise-subscriptions.pdf"'
        }
      }));
    });
    doc.on('error', (e) => reject(e));

    renderHeader(doc, `Subscription Export • ${new Date().toLocaleString()}`);

    const rows = subs.map((s: { name: string; cost: number; currency: string; billingCycle: string; nextBillingDate?: number; category?: string }) => [
      s.name,
      (typeof s.cost === 'number' ? s.cost.toFixed(2) : String(s.cost)),
      s.currency,
      s.billingCycle,
      s.nextBillingDate ? new Date(s.nextBillingDate).toISOString() : '',
      s.category || '—'
    ]);

    renderTable(doc, rows);

    doc.moveDown(1.5).fontSize(9).fillColor('#666').text('Generated by SubWise');
    doc.end();
  });
}


